[{"name":"app.R","content":"library(shiny)\nlibrary(uuid)\nlibrary(grid)\nif(FALSE)library(shinylive)\n# UI -----------------------------------------------------------------------\nui <- fluidPage(\n  tags$head(\n    tags$style(\n      HTML(paste(\n        \"body {background: white; color: black;}\",\n        \"#plot {cursor: crosshair;}\",\n        \"h3 {margin-bottom: 20px; text-align:center;}\",\n        \"#exit {position: absolute; top: 10px; right: 10px;}\",\n        sep = \"\\n\"\n      ))\n    )\n  ),\n  titlePanel(h3(\"Click on the square that is larger\")),\n  fluidRow(\n    column(12,\n           plotOutput(\"plot\", height = \"400px\", click = \"plot_click\"),\n           actionButton(\"exit\", \"Exit & Download\", class = \"btn-primary\")\n    )\n  ),\n  \n  # JavaScript for file download\n  tags$script(HTML(\"\n    function downloadCSV(csvContent, filename) {\n      // Create a blob with the CSV content\n      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\n      \n      // Create a temporary URL for the blob\n      const url = URL.createObjectURL(blob);\n      \n      // Create a temporary anchor element and trigger download\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = filename;\n      link.style.display = 'none';\n      \n      // Add to DOM, click, and remove\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      \n      // Clean up the URL object\n      URL.revokeObjectURL(url);\n    }\n    \n    // Listen for messages from Shiny\n    Shiny.addCustomMessageHandler('downloadFile', function(message) {\n      downloadCSV(message.content, message.filename);\n    });\n  \"))\n)\n\n# Server -------------------------------------------------------------------\nserver <- function(input, output, session) {\n  # Constants\n  fixed_area <- 9\n  cross_thresh <- 0.05  # fraction of plot (npc) for cross region ~Â±0.05\n  \n  # Session ID & results\n  session_id <- UUIDgenerate()\n  results <- reactiveVal(\n    data.frame(\n      trial = integer(),\n      ref_position = character(),\n      var_area = numeric(),\n      response = character(),\n      correct = logical(),\n      rt = numeric(),\n      stringsAsFactors = FALSE\n    )\n  )\n  \n  # Reactive state: phase = 'idle' or 'trial'; ready for click\n  state <- reactiveValues(\n    phase = 'idle',  # 'idle' before trial start, 'trial' during stimulus\n    ready = TRUE,    # only allow start when ready=TRUE\n    trial = 0,\n    ref_left = TRUE,\n    var_area = NA_real_,\n    start_time = Sys.time()\n  )\n  \n  # Function to start a new trial\n  newTrial <- function() {\n    state$trial <- state$trial + 1\n    state$ref_left <- sample(c(TRUE, FALSE), 1)\n    state$var_area <- runif(1, 8, 15)\n    state$start_time <- Sys.time()\n    state$phase <- 'trial'\n  }\n  \n  # After leaving trial, schedule readiness after 0.5s\n  observe({\n    req(state$phase == 'idle' && !state$ready)\n    invalidateLater(500, session)\n    isolate({ state$ready <- TRUE })\n  })\n  \n  # Handle all plot clicks\n  observeEvent(input$plot_click, {\n    click <- input$plot_click\n    x <- click$x; y <- click$y\n    if (state$phase == 'idle' && state$ready) {\n      # start trial only if clicked on fixation cross area\n      if (abs(x - 0.5) <= cross_thresh && abs(y - 0.5) <= cross_thresh) {\n        state$ready <- FALSE\n        newTrial()\n      }\n    } else if (state$phase == 'trial') {\n      # record response during trial\n      resp_left <- (x < 0.5)\n      response <- ifelse(resp_left, 'L', 'R')\n      correct_answer <- if (state$var_area > fixed_area) {\n        if (state$ref_left) 'R' else 'L'\n      } else {\n        if (state$ref_left) 'L' else 'R'\n      }\n      correctness <- (response == correct_answer)\n      rt <- as.numeric(difftime(Sys.time(), state$start_time, units = 'secs'))\n      df <- results()\n      df <- rbind(df, data.frame(\n        trial = state$trial,\n        ref_position = ifelse(state$ref_left, 'L', 'R'),\n        var_area = state$var_area,\n        response = response,\n        correct = correctness,\n        rt = rt,\n        stringsAsFactors = FALSE\n      ))\n      results(df)\n      # end trial, go to idle\n      state$phase <- 'idle'\n      state$var_area <- NA_real_\n      state$ready <- FALSE\n    }\n  })\n  \n  # Render based on phase\n  output$plot <- renderPlot({\n    grid.newpage()\n    if (state$phase == 'idle') {\n      # Draw fixation cross\n      grid.lines(x = unit.c(unit(0.5, 'npc') - unit(5, 'mm'), unit(0.5, 'npc') + unit(5, 'mm')),\n                 y = unit(0.5, 'npc'), gp = gpar(lwd = 2))\n      grid.lines(x = unit(0.5, 'npc'),\n                 y = unit.c(unit(0.5, 'npc') - unit(5, 'mm'), unit(0.5, 'npc') + unit(5, 'mm')),\n                 gp = gpar(lwd = 2))\n      grid.text(paste0('Click cross to start trial: ', state$trial + 1), y = unit(0.3, 'npc'))\n      grid.text(session_id, y = unit(0.2, \"npc\"), gp = gpar(col = \"lightgrey\"))\n      if (!state$ready) {\n        grid.rect(gp = gpar(fill = \"white\", alpha = 0)) # no-op, placeholder\n      }\n    } else if (state$phase == 'trial') {\n      # Draw squares\n      fixed_side <- sqrt(fixed_area)\n      var_side <- sqrt(state$var_area)\n      x_ref <- if (state$ref_left) 0.25 else 0.75\n      x_var <- if (state$ref_left) 0.75 else 0.25\n      pushViewport(viewport(x = x_ref, y = 0.5, width = 0.5, height = 0.5,\n                            just = c('center','center'), angle = 45))\n      grid.rect(width = unit(fixed_side, 'mm'), height = unit(fixed_side, 'mm'), gp = gpar(fill = 'black'))\n      popViewport()\n      pushViewport(viewport(x = x_var, y = 0.5, width = 0.5, height = 0.5,\n                            just = c('center','center'), angle = 45))\n      grid.rect(width = unit(var_side, 'mm'), height = unit(var_side, 'mm'), gp = gpar(fill = 'black'))\n      popViewport()\n    }\n  })\n  \n  # Handle exit button - trigger file download via JavaScript\n  observeEvent(input$exit, {\n    # Convert dataframe to CSV string\n    csv_string <- paste(capture.output(write.csv(results(), row.names = FALSE)), collapse = \"\\n\")\n    \n    # Create filename with UUID\n    filename <- paste0(session_id, \".csv\")\n    \n    # Send message to JavaScript to trigger download\n    session$sendCustomMessage(\n      type = \"downloadFile\",\n      message = list(\n        content = csv_string,\n        filename = filename\n      )\n    )\n  })\n}\n\n# Run ---------------------------------------------------------------------\nshinyApp(ui = ui, server = server)\n","type":"text"}]
